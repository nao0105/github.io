<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Phaser: Ghost Drift - 背景を画面にぴったりフィット</title>
  <style>
    html,body { height:100%; margin:0; }
    body { margin:0; background:#000; color:#fff; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Meiryo", sans-serif; }
    #game-container { width:100%; height:100vh; display:flex; align-items:center; justify-content:center; position:relative; }
    /* Canvas を pixelated 表示にしてピクセルアートがくっきりするように */
    #game-container canvas { image-rendering: pixelated; image-rendering: crisp-edges; }
    #bg-controls { position:absolute; right:14px; top:14px; z-index:1000; display:flex; gap:8px; }
    #bg-controls button { background:#2d3436; color:#fff; border:none; padding:8px 12px; border-radius:6px; cursor:pointer; }
    #bg-preview { width:120px; height:80px; object-fit:cover; border:2px solid rgba(255,255,255,0.06); display:none; }
    .note { position:absolute; left:12px; bottom:12px; color:#b2bec3; font-size:12px; pointer-events:none; z-index:1000; }
  </style>
</head>
<body>
  <div id="game-container"></div>

  <div id="bg-controls">
    <button id="choose-bg-btn">背景画像を選択</button>
    <button id="clear-bg-btn">カスタム背景クリア</button>
    <img id="bg-preview" alt="bg preview"/>
    <input id="bg-input" type="file" accept="image/*" style="display:none" />
  </div>

  <div class="note">操作: ← → (A/D) / タッチボタン、ジャンプ: ↑ / Space / タッチ</div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>

  <script>
  (function(){
    const WIDTH = 800, HEIGHT = 600;
    const LS_KEY = 'phaser_custom_bg_dataurl';

    // UI: カスタム背景選択
    const chooseBtn = document.getElementById('choose-bg-btn');
    const clearBtn = document.getElementById('clear-bg-btn');
    const fileInput = document.getElementById('bg-input');
    const preview = document.getElementById('bg-preview');

    const existing = localStorage.getItem(LS_KEY);
    if (existing) { preview.src = existing; preview.style.display = 'inline-block'; }

    chooseBtn.addEventListener('click', ()=> fileInput.click());
    fileInput.addEventListener('change', (ev) => {
      const f = ev.target.files && ev.target.files[0];
      if (!f) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        const dataURL = e.target.result;
        try {
          localStorage.setItem(LS_KEY, dataURL);
          preview.src = dataURL; preview.style.display = 'inline-block';
          if (confirm('カスタム背景を保存しました。ページを再読み込みして反映しますか？')) location.reload();
        } catch (err) {
          alert('保存に失敗しました（画像が大きすぎる可能性があります）。画像を縮小して再試行してください。');
          console.error(err);
        }
      };
      reader.readAsDataURL(f);
    });

    clearBtn.addEventListener('click', ()=> {
      localStorage.removeItem(LS_KEY);
      preview.style.display = 'none';
      if (confirm('カスタム背景をクリアして生成背景に戻します。ページを再読み込みしますか？')) location.reload();
    });

    /* ----------------------------
       Pixel forest generator (finer)
       ---------------------------- */
    function generatePixelForestCanvas(width, height, pixelSize) {
      const cols = Math.ceil(width / pixelSize);
      const rows = Math.ceil(height / pixelSize);
      const canvas = document.createElement('canvas');
      canvas.width = width; canvas.height = height;
      const ctx = canvas.getContext('2d');

      // Palettes
      const canopyPalette = ['#0b1c3a','#16244f','#223a6d','#314f86','#4a6aa2'];
      const midPalette = ['#213d47','#2a4f58','#3b6572'];
      const clearingPalette = ['#8aa0c6','#6f88b0','#556b98'];
      const trunkPalette = ['#2b1710','#311e13','#26160f'];
      const grassPalette = ['#223b30','#183126','#2b4b3b'];

      // base
      ctx.fillStyle = '#07121f';
      ctx.fillRect(0,0,width,height);

      const cx = Math.floor(cols * 0.5);
      const cy = Math.floor(rows * 0.56);
      const rx = Math.floor(cols * 0.30);
      const ry = Math.floor(rows * 0.12);

      for (let gy = 0; gy < rows; gy++) {
        for (let gx = 0; gx < cols; gx++) {
          const px = gx * pixelSize;
          const py = gy * pixelSize;
          const dx = gx - cx;
          const dy = gy - cy;
          const dist = Math.sqrt((dx*dx)/(rx*rx) + (dy*dy)/(ry*ry));

          if (dist < 0.85) {
            ctx.fillStyle = clearingPalette[Math.floor(Math.random() * clearingPalette.length)];
            ctx.fillRect(px, py, pixelSize, pixelSize);
            continue;
          }

          const canopyBias = 1 - (gy / (rows * 0.9));
          const canopyChance = Math.min(0.9, 0.25 + canopyBias*0.8 + Math.random()*0.15);
          if (Math.random() < canopyChance) {
            ctx.fillStyle = canopyPalette[Math.floor(Math.random()*canopyPalette.length)];
            ctx.fillRect(px, py, pixelSize, pixelSize);
            if (Math.random() < 0.06) {
              ctx.fillStyle = midPalette[Math.floor(Math.random()*midPalette.length)];
              ctx.fillRect(px + 1, py + 1, Math.max(1, pixelSize-2), Math.max(1, pixelSize-2));
            }
            continue;
          }

          if (Math.random() < 0.28) {
            ctx.fillStyle = midPalette[Math.floor(Math.random()*midPalette.length)];
            ctx.fillRect(px, py, pixelSize, pixelSize);
            continue;
          }

          ctx.fillStyle = '#081428';
          ctx.fillRect(px, py, pixelSize, pixelSize);
        }
      }

      // trunks
      const trunkCount = 10;
      for (let t = 0; t < trunkCount; t++) {
        const sideBias = Math.random();
        const posX = sideBias < 0.5 ? Math.floor(Math.random()*Math.floor(cols*0.18)) + Math.floor(cols*0.02) : Math.floor(cols - Math.random()*Math.floor(cols*0.18)) - Math.floor(cols*0.02);
        const trunkW = Math.max(2, Math.floor(Math.random()*6 + 2));
        const trunkTop = Math.floor(Math.random()*Math.floor(rows*0.28)) + Math.floor(rows*0.3);
        for (let gy = trunkTop; gy < rows - 6; gy++) {
          for (let gxOff = -Math.floor(trunkW/2); gxOff <= Math.floor(trunkW/2); gxOff++) {
            const tx = Math.min(cols-1, Math.max(0, posX + gxOff));
            const px = tx * pixelSize;
            const py = gy * pixelSize;
            ctx.fillStyle = trunkPalette[Math.floor(Math.random()*trunkPalette.length)];
            ctx.fillRect(px, py, pixelSize, pixelSize);
          }
        }
        // canopy
        const canopyTop = trunkTop - Math.floor(Math.random()*6 + 4);
        const canopyRadius = Math.floor(6 + Math.random()*12);
        for (let oy=-canopyRadius; oy<=canopyRadius; oy++){
          for (let ox=-canopyRadius; ox<=canopyRadius; ox++){
            const dist = Math.sqrt(ox*ox + oy*oy);
            if (dist < canopyRadius - (Math.random()*1.2)) {
              const tx = posX + ox;
              const ty = canopyTop + oy;
              if (tx>=0 && tx<cols && ty>=0 && ty<rows) {
                const px = tx * pixelSize, py = ty * pixelSize;
                ctx.fillStyle = canopyPalette[Math.floor(Math.random()*canopyPalette.length)];
                ctx.fillRect(px, py, pixelSize, pixelSize);
              }
            }
          }
        }
      }

      // foreground grass
      for (let gx=0; gx<cols; gx++){
        for (let gy = rows - 8; gy < rows; gy++){
          if (Math.random() < 0.68) {
            ctx.fillStyle = grassPalette[Math.floor(Math.random()*grassPalette.length)];
            ctx.fillRect(gx*pixelSize, gy*pixelSize, pixelSize, pixelSize);
          }
        }
      }

      // fog speckles
      for (let layer=0; layer<3; layer++){
        const fogAlpha = 0.04 + layer * 0.03;
        const fogColor = ['#9fb7db','#8aa0c6','#6f88b0'][layer % 3];
        for (let i=0; i<Math.floor(cols*rows*0.01); i++){
          const gx = Math.floor(Math.random()*cols);
          const gy = Math.floor((rows - (rows*0.5)) + Math.random()*(rows*0.5));
          ctx.fillStyle = hexToRgba(fogColor, fogAlpha * Math.random());
          ctx.fillRect(gx*pixelSize, gy*pixelSize, pixelSize, pixelSize);
        }
      }

      // small highlights
      for (let i=0;i<Math.floor(cols*rows*0.015);i++){
        const gx = Math.floor(Math.random()*cols);
        const gy = Math.floor(Math.random()*rows);
        ctx.fillStyle = 'rgba(255,255,255,0.02)';
        ctx.fillRect(gx*pixelSize, gy*pixelSize, Math.max(1, Math.floor(pixelSize*0.6)), Math.max(1, Math.floor(pixelSize*0.6)));
      }

      return canvas;
    }

    function hexToRgba(hex, alpha) {
      const h = hex.replace('#','');
      const bigint = parseInt(h,16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return 'rgba('+r+','+g+','+b+','+alpha+')';
    }

    /* ----------------------------
       Phaser scenes
       - If a custom (localStorage) or embedded image exists, it will be used and scaled to COVER the game canvas (アスペクト比保持)
       - Otherwise uses the generated pixel forest texture as default and scaled to cover.
       ---------------------------- */

    function BootScene() { Phaser.Scene.call(this, { key:'BootScene' }); }
    BootScene.prototype = Object.create(Phaser.Scene.prototype);
    BootScene.prototype.constructor = BootScene;

    BootScene.prototype.create = function() {
      // register generated default background
      const pixelSize = 4; // finer pixels
      const canvas = generatePixelForestCanvas(WIDTH, HEIGHT, pixelSize);
      try {
        this.textures.addCanvas('bg-default', canvas);
      } catch (err) {
        this.textures.addBase64('bg-default', canvas.toDataURL());
      }

      // register custom if saved
      const custom = localStorage.getItem(LS_KEY);
      if (custom) {
        try { this.textures.addBase64('bg-custom', custom); } catch (err) { console.warn('bg-custom add failed', err); }
      }

      // create player/enemy/coin/ui textures
      const g = this.make.graphics({ x:0, y:0, add:false });
      // player
      g.fillStyle(0x73d8ff); g.fillRoundedRect(4,8,56-8,64-16,12);
      g.fillStyle(0xffffff,0.35); g.fillEllipse(56-18,18,18,10);
      g.fillStyle(0x222222); g.fillEllipse(20,28,8,10); g.fillEllipse(36,28,8,10);
      g.fillStyle(0xffffff); g.fillCircle(22,26,2); g.fillCircle(38,26,2);
      g.fillStyle(0xff9fb1); g.fillCircle(18,36,4); g.fillCircle(38,36,4);
      g.fillStyle(0x662200); g.fillRect(26,40,6,3);
      g.fillStyle(0xffe066); g.fillRoundedRect(12,10,32,8,4);
      g.generateTexture('player',56,64); g.clear();

      // enemy
      g.fillStyle(0xffffff,0.95); g.fillCircle(48/2,18,18); g.fillRoundedRect(48/2-18,18,36,22,8);
      g.fillCircle(48/2-12,42,8); g.fillCircle(48/2,42,8); g.fillCircle(48/2+12,42,8);
      g.fillStyle(0x222222); g.fillEllipse(48/2-8,20,6,8); g.fillEllipse(48/2+8,20,6,8);
      g.fillStyle(0x662200); g.fillEllipse(48/2,30,4,3);
      g.generateTexture('enemy',48,56); g.clear();

      // coin
      g.fillStyle(0xffd86b); g.fillCircle(12,12,12); g.lineStyle(2,0xbb8a00); g.strokeCircle(12,12,12);
      g.generateTexture('coin',24,24); g.clear();

      // UI
      g.fillStyle(0x2f3542,0.9); g.fillRoundedRect(0,0,72,72,12); g.lineStyle(4,0xffffff,0.6); g.strokeRoundedRect(0,0,72,72,12);
      g.generateTexture('btn',72,72); g.clear();
      g.fillStyle(0xffffff); g.fillTriangle(28,36,44,20,44,52); g.generateTexture('arrow-left',72,72); g.clear();
      g.fillStyle(0xffffff); g.fillTriangle(44,36,28,20,28,52); g.generateTexture('arrow-right',72,72); g.clear();
      g.fillStyle(0xffffff); g.fillRect(30,20,12,32); g.generateTexture('jump-icon',72,72); g.clear();

      this.scene.start('MenuScene');
    };

    // MenuScene
    function MenuScene() { Phaser.Scene.call(this, { key:'MenuScene' }); }
    MenuScene.prototype = Object.create(Phaser.Scene.prototype);
    MenuScene.prototype.constructor = MenuScene;
    MenuScene.prototype.create = function() {
      const cx = this.cameras.main.centerX, cy = this.cameras.main.centerY;
      this.add.text(cx, cy-120, 'Phaser: Ghost Drift', { fontSize:'32px', color:'#fff' }).setOrigin(0.5);
      this.add.text(cx, cy-80, '背景は画像を画面にぴったり合わせて表示します（アスペクト比は維持）。', { fontSize:'14px', color:'#dfe6e9', wordWrap:{ width:560 } }).setOrigin(0.5);
      const start = this.add.rectangle(cx, cy, 260,64, 0x2ecc71).setInteractive({ useHandCursor:true });
      this.add.text(cx, cy, 'START', { fontSize:'28px', color:'#fff' }).setOrigin(0.5);
      start.on('pointerdown', ()=> this.scene.start('GameScene'));
    };

    // GameScene
    function GameScene() { Phaser.Scene.call(this, { key:'GameScene' }); this.score = 0; }
    GameScene.prototype = Object.create(Phaser.Scene.prototype);
    GameScene.prototype.constructor = GameScene;

    GameScene.prototype.create = function() {
      const w = this.scale.width, h = this.scale.height;

      // Determine which background to use: custom -> embedded -> generated default
      const useKey = this.textures.exists('bg-custom') ? 'bg-custom' : (this.textures.exists('bg-embedded') ? 'bg-embedded' : 'bg-default');
      this.bgKey = useKey;

      // If the texture is an image/canvas, create an Image and scale to COVER the screen (アスペクト比を保持して画面を満たす)
      // Note: generated 'bg-default' is a canvas sized to game size, but we still handle it uniformly.
      const tex = this.textures.get(useKey);
      const src = tex && tex.getSourceImage ? tex.getSourceImage() : null;
      if (src) {
        // Use an Image (not tileSprite) so we can setDisplaySize precisely
        this.bgImage = this.add.image(w/2, h/2, useKey).setDepth(-40).setScrollFactor(0);
        this._resizeBackgroundImage(); // initial sizing
        // handle resize
        this.scale.on('resize', () => this._resizeBackgroundImage(), this);
      } else {
        // fallback: if something went wrong, make a tileSprite with bg-default
        this.bgTile = this.add.tileSprite(0,0,w,h,'bg-default').setOrigin(0).setDepth(-40);
      }

      // ground
      const ground = this.add.rectangle(w/2, h-16, w, 32, 0x000000, 0);
      this.physics.add.existing(ground, true);

      // player
      this.player = this.physics.add.sprite(120, h-120, 'player');
      this.player.setCollideWorldBounds(true); this.player.setBounce(0.05);
      this.player.body.setSize(40,52).setOffset(8,8);
      this.player.setMaxVelocity(320,900); this.player.setDragX(900);
      this.physics.add.collider(this.player, ground);

      // groups and collisions
      this.enemies = this.physics.add.group();
      this.coins = this.physics.add.group();
      this.physics.add.overlap(this.player, this.enemies, this.onPlayerHit, null, this);
      this.physics.add.overlap(this.player, this.coins, this.onCollectCoin, null, this);

      // HUD
      this.scoreText = this.add.text(16,16,'SCORE: 0',{ fontSize:'20px', color:'#fff' }).setDepth(1000);

      // input + touch UI
      this.cursors = this.input.keyboard.createCursorKeys();
      this.keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);
      this.keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);
      this.keySpace = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
      this.createTouchControls();

      // spawn timers
      this.spawnEnemyEvent = this.time.addEvent({ delay: 1300, callback: this.spawnEnemy, callbackScope: this, loop: true });
      this.spawnCoinEvent = this.time.addEvent({ delay: 1800, callback: this.spawnCoin, callbackScope: this, loop: true });

      this.isGameOver = false;
      this.score = 0;
    };

    // Resize helper: scale bgImage to COVER
    GameScene.prototype._resizeBackgroundImage = function() {
      if (!this.bgImage) return;
      const w = this.scale.width, h = this.scale.height;
      const tex = this.textures.get(this.bgKey);
      const src = tex.getSourceImage();
      if (!src) return;
      const tw = src.width, th = src.height;
      // If the source is a canvas texture sized exactly to the game, just set display size to game
      if (tw === w && th === h) {
        this.bgImage.setDisplaySize(w, h);
        this.bgImage.setPosition(w/2, h/2);
        return;
      }
      // scale to cover (preserve aspect)
      const scale = Math.max(w / tw, h / th);
      const dispW = Math.ceil(tw * scale);
      const dispH = Math.ceil(th * scale);
      this.bgImage.setDisplaySize(dispW, dispH);
      this.bgImage.setPosition(w/2, h/2);
      // ensure pixelated rendering via CSS on canvas; for image elements inside canvas texture it will use canvas rendering.
    };

    GameScene.prototype.createTouchControls = function(){
      const margin = 16, btnSize = 72;
      const width = this.scale.width, height = this.scale.height;

      this.leftBtn = this.add.image(margin + btnSize/2, height - margin - btnSize/2, 'btn').setInteractive();
      this.leftBtnIcon = this.add.image(this.leftBtn.x, this.leftBtn.y, 'arrow-left');
      this.leftPressed = false;
      this.leftBtn.on('pointerdown', ()=> this.leftPressed = true);
      this.leftBtn.on('pointerup', ()=> this.leftPressed = false);
      this.leftBtn.on('pointerout', ()=> this.leftPressed = false);
      this.leftBtn.setDepth(40); this.leftBtnIcon.setDepth(41);

      this.rightBtn = this.add.image(margin + btnSize/2 + (btnSize + 10), height - margin - btnSize/2, 'btn').setInteractive();
      this.rightBtnIcon = this.add.image(this.rightBtn.x, this.rightBtn.y, 'arrow-right');
      this.rightPressed = false;
      this.rightBtn.on('pointerdown', ()=> this.rightPressed = true);
      this.rightBtn.on('pointerup', ()=> this.rightPressed = false);
      this.rightBtn.on('pointerout', ()=> this.rightPressed = false);
      this.rightBtn.setDepth(40); this.rightBtnIcon.setDepth(41);

      this.jumpBtn = this.add.image(width - margin - btnSize/2, height - margin - btnSize/2, 'btn').setInteractive();
      this.jumpBtnIcon = this.add.image(this.jumpBtn.x, this.jumpBtn.y, 'jump-icon');
      this.jumpPressed = false;
      this.jumpBtn.on('pointerdown', ()=> { this.jumpPressed = true; this.tryJump(); });
      this.jumpBtn.on('pointerup', ()=> this.jumpPressed = false);
      this.jumpBtn.on('pointerout', ()=> this.jumpPressed = false);
      this.jumpBtn.setDepth(40); this.jumpBtnIcon.setDepth(41);
    };

    GameScene.prototype.update = function(time, delta) {
      if (this.isGameOver) return;

      // If using a tile background (fallback), scroll a little
      if (this.bgTile) {
        this.bgTile.tilePositionX += 0.02 * delta * 0.02;
      } else if (this.bgImage) {
        // optionally animate bgImage tile position by small offset via position jitter (disabled by default)
      }

      // Movement input
      const accel = 900;
      if ((this.cursors.left && this.cursors.left.isDown) || this.keyA.isDown || this.leftPressed) {
        this.player.setAccelerationX(-accel); this.player.setFlipX(true);
      } else if ((this.cursors.right && this.cursors.right.isDown) || this.keyD.isDown || this.rightPressed) {
        this.player.setAccelerationX(accel); this.player.setFlipX(false);
      } else {
        this.player.setAccelerationX(0);
      }

      if (Phaser.Input.Keyboard.JustDown(this.cursors.up) || Phaser.Input.Keyboard.JustDown(this.keySpace)) this.tryJump();

      // cleanup objects off-screen
      const w = this.scale.width, h = this.scale.height;
      this.enemies.children.iterate(e => { if (e && (e.x < -160 || e.x > w + 160)) e.destroy(); });
      this.coins.children.iterate(c => { if (c && c.y > h + 160) c.destroy(); });
    };

    GameScene.prototype.tryJump = function() {
      const onGround = this.player.body.blocked.down || this.player.body.touching.down;
      if (onGround) this.player.setVelocityY(-480);
    };

    // spawn enemies (flow horizontally with slight sway)
    GameScene.prototype.spawnEnemy = function() {
      const w = this.scale.width, h = this.scale.height;
      const fromRight = Phaser.Math.Between(0,1) === 1;
      const y = Phaser.Math.Between(80, h - 160);
      const x = fromRight ? w + 48 : -48;
      const enemy = this.enemies.create(x, y, 'enemy');
      if (enemy.body) enemy.body.setAllowGravity(false);
      enemy.setBounce(0);
      const speed = Phaser.Math.Between(30, 80);
      enemy.setVelocityX(fromRight ? -speed : speed);
      enemy.setVelocityY(0);
      const sway = Phaser.Math.Between(12, 48);
      const period = Phaser.Math.Between(1600, 3600);
      this.tweens.add({ targets: enemy, y: y + Phaser.Math.Between(-sway, sway), duration: period, yoyo:true, repeat:-1, ease:'Sine.easeInOut' });
      this.tweens.add({ targets: enemy, angle: Phaser.Math.Between(-6,6), duration: Phaser.Math.Between(1200,2400), yoyo:true, repeat:-1, ease:'Sine.easeInOut' });
    };

    // coins fall from top
    GameScene.prototype.spawnCoin = function() {
      const x = Phaser.Math.Between(24, this.scale.width - 24);
      const coin = this.coins.create(x, -28, 'coin');
      if (coin.body) coin.body.setAllowGravity(true);
      coin.setBounce(0);
      coin.setVelocityX(Phaser.Math.Between(-30, 30));
      coin.setVelocityY(Phaser.Math.Between(60, 140));
      coin.setCollideWorldBounds(false);
      this.tweens.add({ targets: coin, angle: 360, duration: 1400, repeat:-1, ease:'Linear' });
      this.tweens.add({ targets: coin, x: x + Phaser.Math.Between(-24,24), duration: Phaser.Math.Between(1000,2200), yoyo:true, repeat:-1, ease:'Sine.easeInOut' });
    };

    GameScene.prototype.onPlayerHit = function() {
      if (this.isGameOver) return;
      this.isGameOver = true;
      this.cameras.main.shake(220, 0.02);
      this.spawnEnemyEvent.remove(false);
      this.spawnCoinEvent.remove(false);
      this.tweens.add({ targets: this.player, alpha: 0, scale: 0.6, duration: 500, ease: 'Cubic.easeIn' });
      this.time.delayedCall(700, ()=> this.scene.start('GameOverScene', { score: this.score }));
    };

    GameScene.prototype.onCollectCoin = function(player, coin) {
      coin.destroy();
      this.score += 10;
      this.scoreText.setText('SCORE: ' + this.score);
      this.tweens.add({ targets: this.scoreText, scale: 1.15, duration: 100, yoyo:true });
    };

    // GameOverScene
    function GameOverScene() { Phaser.Scene.call(this, { key:'GameOverScene' }); }
    GameOverScene.prototype = Object.create(Phaser.Scene.prototype);
    GameOverScene.prototype.constructor = GameOverScene;
    GameOverScene.prototype.init = function(data){ this.finalScore = data.score || 0; };
    GameOverScene.prototype.create = function(){
      const cx = this.cameras.main.centerX, cy = this.cameras.main.centerY;
      this.add.text(cx, cy-80, 'GAME OVER', { fontSize:'40px', color:'#ff7675' }).setOrigin(0.5);
      this.add.text(cx, cy-30, `SCORE: ${this.finalScore}`, { fontSize:'28px', color:'#fff' }).setOrigin(0.5);
      const retry = this.add.rectangle(cx, cy+30, 220,56,0x0984e3).setInteractive({ useHandCursor:true });
      this.add.text(cx, cy+30, 'RETRY', { fontSize:'22px', color:'#fff' }).setOrigin(0.5);
      retry.on('pointerdown', ()=> this.scene.start('GameScene'));
      const menu = this.add.rectangle(cx, cy+100, 220,46,0x636e72).setInteractive({ useHandCursor:true });
      this.add.text(cx, cy+100, 'MENU', { fontSize:'18px', color:'#fff' }).setOrigin(0.5);
      menu.on('pointerdown', ()=> this.scene.start('MenuScene'));
      const prev = parseInt(localStorage.getItem('phaser_sample_highscore') || '0', 10);
      if (this.finalScore > prev) { localStorage.setItem('phaser_sample_highscore', this.finalScore); this.add.text(cx, cy+160, 'NEW HIGH SCORE!', { fontSize:'16px', color:'#ffd32a' }).setOrigin(0.5); }
      else { this.add.text(cx, cy+160, `HIGH: ${prev}`, { fontSize:'16px', color:'#dfe6e9' }).setOrigin(0.5); }
    };

    // Phaser game start
    const config = {
      type: Phaser.AUTO, width: WIDTH, height: HEIGHT, parent: 'game-container',
      backgroundColor: '#0a0f0e',
      physics: { default:'arcade', arcade:{ gravity:{ y:1000 }, debug:false } },
      scene: [BootScene, MenuScene, GameScene, GameOverScene],
      scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH }
    };
    new Phaser.Game(config);

  })();
  </script>
</body>
</html>